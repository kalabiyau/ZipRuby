<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>Class: ZipRuby::Archive</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>zipruby.c
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Object
  
</nav>

    <!-- Included Modules -->
<nav id="includes-section" class="section">
  <h3 class="section-header">Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">Enumerable</span>
  
  
  </ul>
</nav>

    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-decrypt">::decrypt</a>
    
    <li><a href="#method-c-encrypt">::encrypt</a>
    
    <li><a href="#method-c-open">::open</a>
    
    <li><a href="#method-c-open_buffer">::open_buffer</a>
    
    <li><a href="#method-i-3C-3C">#&lt;&lt;</a>
    
    <li><a href="#method-i-add">#add</a>
    
    <li><a href="#method-i-add_buffer">#add_buffer</a>
    
    <li><a href="#method-i-add_dir">#add_dir</a>
    
    <li><a href="#method-i-add_file">#add_file</a>
    
    <li><a href="#method-i-add_io">#add_io</a>
    
    <li><a href="#method-i-add_or_replace">#add_or_replace</a>
    
    <li><a href="#method-i-add_or_replace_buffer">#add_or_replace_buffer</a>
    
    <li><a href="#method-i-add_or_replace_file">#add_or_replace_file</a>
    
    <li><a href="#method-i-add_or_replace_io">#add_or_replace_io</a>
    
    <li><a href="#method-i-close">#close</a>
    
    <li><a href="#method-i-comment">#comment</a>
    
    <li><a href="#method-i-comment-3D">#comment=</a>
    
    <li><a href="#method-i-commit">#commit</a>
    
    <li><a href="#method-i-decrypt">#decrypt</a>
    
    <li><a href="#method-i-each">#each</a>
    
    <li><a href="#method-i-encrypt">#encrypt</a>
    
    <li><a href="#method-i-fdelete">#fdelete</a>
    
    <li><a href="#method-i-fopen">#fopen</a>
    
    <li><a href="#method-i-frename">#frename</a>
    
    <li><a href="#method-i-frevert">#frevert</a>
    
    <li><a href="#method-i-funchange">#funchange</a>
    
    <li><a href="#method-i-funchange_all">#funchange_all</a>
    
    <li><a href="#method-i-get_comment">#get_comment</a>
    
    <li><a href="#method-i-get_fcomment">#get_fcomment</a>
    
    <li><a href="#method-i-get_name">#get_name</a>
    
    <li><a href="#method-i-get_stat">#get_stat</a>
    
    <li><a href="#method-i-locate_name">#locate_name</a>
    
    <li><a href="#method-i-num_files">#num_files</a>
    
    <li><a href="#method-i-open-3F">#open?</a>
    
    <li><a href="#method-i-read">#read</a>
    
    <li><a href="#method-i-replace">#replace</a>
    
    <li><a href="#method-i-replace_buffer">#replace_buffer</a>
    
    <li><a href="#method-i-replace_file">#replace_file</a>
    
    <li><a href="#method-i-replace_io">#replace_io</a>
    
    <li><a href="#method-i-revert">#revert</a>
    
    <li><a href="#method-i-set_fcomment">#set_fcomment</a>
    
    <li><a href="#method-i-unchange">#unchange</a>
    
    <li><a href="#method-i-update">#update</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../ChangeLog.html">ChangeLog</a>
  
    <li class="file"><a href="../README_txt.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../ZipRuby.html">ZipRuby</a>
  
    <li><a href="../ZipRuby/Archive.html">ZipRuby::Archive</a>
  
    <li><a href="../ZipRuby/Error.html">ZipRuby::Error</a>
  
    <li><a href="../ZipRuby/File.html">ZipRuby::File</a>
  
    <li><a href="../ZipRuby/Stat.html">ZipRuby::Stat</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class ZipRuby::Archive</h1>

  <div id="description" class="description">
    
  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-decrypt" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">decrypt</span><span
            class="method-args">(p1, p2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="decrypt-source">
            <pre>static VALUE zipruby_archive_s_decrypt(VALUE self, VALUE path, VALUE password) {
  int res;
  int errorp, wrongpwd;
  long pwdlen;

  Check_Type(path, T_STRING);
  Check_Type(password, T_STRING);
  pwdlen = RSTRING_LEN(password);

  if (pwdlen &lt; 1) {
    rb_raise(Error, &quot;Decrypt archive failed - %s: Password is empty&quot;, RSTRING_PTR(path));
  } else if (pwdlen &gt; 0xff) {
    rb_raise(Error, &quot;Decrypt archive failed - %s: Password is too long&quot;, RSTRING_PTR(path));
  }

  res = zip_decrypt(RSTRING_PTR(path), RSTRING_PTR(password), pwdlen, &amp;errorp, &amp;wrongpwd);

  if (res == -1) {
    if (wrongpwd) {
      rb_raise(Error, &quot;Decrypt archive failed - %s: Wrong password&quot;, RSTRING_PTR(path));
    } else {
      char errstr[ERRSTR_BUFSIZE];
      zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
      rb_raise(Error, &quot;Decrypt archive failed - %s: %s&quot;, RSTRING_PTR(path), errstr);
    }
  }

  return (res &gt; 0) ? Qtrue : Qfalse;
}</pre>
          </div><!-- decrypt-source -->
          
        </div>

        

        
      </div><!-- decrypt-method -->

    
      <div id="method-c-encrypt" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">encrypt</span><span
            class="method-args">(p1, p2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="encrypt-source">
            <pre>static VALUE zipruby_archive_s_encrypt(VALUE self, VALUE path, VALUE password) {
  int res;
  int errorp;
  long pwdlen;

  Check_Type(path, T_STRING);
  Check_Type(password, T_STRING);
  pwdlen = RSTRING_LEN(password);

  if (pwdlen &lt; 1) {
    rb_raise(Error, &quot;Encrypt archive failed - %s: Password is empty&quot;, RSTRING_PTR(path));
  } else if (pwdlen &gt; 0xff) {
    rb_raise(Error, &quot;Encrypt archive failed - %s: Password is too long&quot;, RSTRING_PTR(path));
  }

  res = zip_encrypt(RSTRING_PTR(path), RSTRING_PTR(password), pwdlen, &amp;errorp);

  if (res == -1) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Encrypt archive failed - %s: %s&quot;, RSTRING_PTR(path), errstr);
  }

  return (res &gt; 0) ? Qtrue : Qfalse;
}</pre>
          </div><!-- encrypt-source -->
          
        </div>

        

        
      </div><!-- encrypt-method -->

    
      <div id="method-c-open" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">open</span><span
            class="method-args">(p1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="open-source">
            <pre>static VALUE zipruby_archive_s_open(int argc, VALUE *argv, VALUE self) {
  VALUE path, flags, comp_level;
  VALUE archive;
  struct zipruby_archive *p_archive;
  int i_flags = 0;
  int errorp;
  int i_comp_level = Z_BEST_COMPRESSION;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;path, &amp;flags, &amp;comp_level);
  Check_Type(path, T_STRING);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  if (!NIL_P(comp_level)) {
    i_comp_level = NUM2INT(comp_level);

    if (i_comp_level != Z_DEFAULT_COMPRESSION &amp;&amp; i_comp_level != Z_NO_COMPRESSION &amp;&amp; (i_comp_level &lt; Z_BEST_SPEED || Z_BEST_COMPRESSION &lt; i_comp_level)) {
      rb_raise(rb_eArgError, &quot;Wrong compression level %d&quot;, i_comp_level);
    }
  }

  archive = rb_funcall(Archive, rb_intern(&quot;new&quot;), 0);
  Data_Get_Struct(archive, struct zipruby_archive, p_archive);

  if ((p_archive-&gt;archive = zip_open(RSTRING_PTR(path), i_flags, &amp;errorp)) == NULL) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Open archive failed - %s: %s&quot;, RSTRING_PTR(path), errstr);
  }

  p_archive-&gt;archive-&gt;comp_level = i_comp_level;
  p_archive-&gt;path = path;
  p_archive-&gt;flags = i_flags;
  p_archive-&gt;sources = rb_ary_new();

  if (rb_block_given_p()) {
    VALUE retval;
    int status;

    retval = rb_protect(rb_yield, archive, &amp;status);
    zipruby_archive_close(archive);

    if (status != 0) {
      rb_jump_tag(status);
    }

    return retval;
  } else {
    return archive;
  }
}</pre>
          </div><!-- open-source -->
          
        </div>

        

        
      </div><!-- open-method -->

    
      <div id="method-c-open_buffer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">open_buffer</span><span
            class="method-args">(p1 = v1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="open_buffer-source">
            <pre>static VALUE zipruby_archive_s_open_buffer(int argc, VALUE *argv, VALUE self) {
  VALUE buffer, flags, comp_level;
  VALUE archive;
  struct zipruby_archive *p_archive;
  void *data = NULL;
  int len = 0, i_flags = 0;
  int errorp;
  int i_comp_level = Z_BEST_COMPRESSION;
  int buffer_is_temporary = 0;

  rb_scan_args(argc, argv, &quot;03&quot;, &amp;buffer, &amp;flags, &amp;comp_level);

  if (FIXNUM_P(buffer) &amp;&amp; NIL_P(comp_level)) {
    comp_level = flags;
    flags = buffer;
    buffer = Qnil;
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  if (!NIL_P(comp_level)) {
    i_comp_level = NUM2INT(comp_level);

    if (i_comp_level != Z_DEFAULT_COMPRESSION &amp;&amp; i_comp_level != Z_NO_COMPRESSION &amp;&amp; (i_comp_level &lt; Z_BEST_SPEED || Z_BEST_COMPRESSION &lt; i_comp_level)) {
      rb_raise(rb_eArgError, &quot;Wrong compression level %d&quot;, i_comp_level);
    }
  }

  if (i_flags &amp; ZIP_CREATE) {
    if (!NIL_P(buffer)) {
      Check_Type(buffer, T_STRING);
    } else {
      buffer = rb_str_new(&quot;&quot;, 0);
      buffer_is_temporary = 1;
    }

    i_flags = (i_flags | ZIP_TRUNC);
  } else if (TYPE(buffer) == T_STRING) {
    data = RSTRING_PTR(buffer);
    len = RSTRING_LEN(buffer);
  } else if (rb_obj_is_instance_of(buffer, rb_cProc)) {
    data = (void *) buffer;
    len = -1;
  } else {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected String or Proc)&quot;, rb_class2name(CLASS_OF(buffer)));
  }

  archive = rb_funcall(Archive, rb_intern(&quot;new&quot;), 0);
  Data_Get_Struct(archive, struct zipruby_archive, p_archive);

  if ((p_archive-&gt;tmpfilnam = zipruby_tmpnam(data, len)) == NULL) {
    rb_raise(Error, &quot;Open archive failed: Failed to create temporary file&quot;);
  }

  if ((p_archive-&gt;archive = zip_open(p_archive-&gt;tmpfilnam, i_flags, &amp;errorp)) == NULL) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Open archive failed: %s&quot;, errstr);
  }

  p_archive-&gt;archive-&gt;comp_level = i_comp_level;
  p_archive-&gt;path = rb_str_new2(p_archive-&gt;tmpfilnam);
  p_archive-&gt;flags = i_flags;
  p_archive-&gt;buffer = buffer;
  p_archive-&gt;sources = rb_ary_new();

  if (rb_block_given_p()) {
    VALUE retval;
    int status;

    retval = rb_protect(rb_yield, archive, &amp;status);
    zipruby_archive_close(archive);

    if (status != 0) {
      rb_jump_tag(status);
    }

    return buffer_is_temporary ? buffer : retval;
  } else {
    return archive;
  }
}</pre>
          </div><!-- open_buffer-source -->
          
        </div>

        

        
      </div><!-- open_buffer-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-3C-3C" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">&lt;&lt;</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="3C-3C-source">
            <pre>static VALUE zipruby_archive_add_io(int argc, VALUE *argv, VALUE self) {
  VALUE name, file, mtime;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  struct read_io *z;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;file);

  if (NIL_P(file)) {
    file = name;
    name = Qnil;
  }

  Check_IO(file);

  if (NIL_P(name)) {
    if (rb_obj_is_kind_of(file, rb_cFile)) {
      name = rb_funcall(rb_cFile, rb_intern(&quot;basename&quot;), 1, rb_funcall(file, rb_intern(&quot;path&quot;), 0));
    } else {
      rb_raise(rb_eRuntimeError, &quot;Add io failed - %s: Entry name is not given&quot;, RSTRING(rb_inspect(file)));
    }
  }

  if (rb_obj_is_kind_of(file, rb_cFile)) {
    mtime = rb_funcall(file, rb_intern(&quot;mtime&quot;), 0);
  } else {
    mtime = rb_funcall(rb_cTime, rb_intern(&quot;now&quot;), 0);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive); 
  Check_Archive(p_archive);

  if ((z = malloc(sizeof(struct read_io))) == NULL) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(rb_eRuntimeError, &quot;Add io failed - %s: Cannot allocate memory&quot;, RSTRING(rb_inspect(file)));
  }

  z-&gt;io = file;
  rb_ary_push(p_archive-&gt;sources, file);
  z-&gt;mtime = TIME2LONG(mtime);

  if ((zsource = zip_source_io(p_archive-&gt;archive, z)) == NULL) {
    free(z);
    rb_raise(Error, &quot;Add io failed - %s: %s&quot;, RSTRING(rb_inspect(file)), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_add(p_archive-&gt;archive, RSTRING_PTR(name), zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add io failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- 3C-3C-source -->
          
        </div>

        

        
      </div><!-- 3C-3C-method -->

    
      <div id="method-i-add" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add-source">
            <pre>static VALUE zipruby_archive_add_function(int argc, VALUE *argv, VALUE self) {
  VALUE name, mtime;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  struct read_proc *z;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;mtime);
  rb_need_block();
  Check_Type(name, T_STRING);

  if (NIL_P(mtime)) {
    mtime = rb_funcall(rb_cTime, rb_intern(&quot;now&quot;), 0);
  } else if (!rb_obj_is_instance_of(mtime, rb_cTime)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Time)&quot;, rb_class2name(CLASS_OF(mtime)));
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive); 
  Check_Archive(p_archive);

  if ((z = malloc(sizeof(struct read_proc))) == NULL) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(rb_eRuntimeError, &quot;Add failed - %s: Cannot allocate memory&quot;, RSTRING_PTR(name));
  }

  z-&gt;proc = rb_block_proc();
  rb_ary_push(p_archive-&gt;sources, z-&gt;proc);
  z-&gt;mtime = TIME2LONG(mtime);

  if ((zsource = zip_source_proc(p_archive-&gt;archive, z)) == NULL) {
    free(z);
    rb_raise(Error, &quot;Add failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_add(p_archive-&gt;archive, RSTRING_PTR(name), zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add file failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- add-source -->
          
        </div>

        

        
      </div><!-- add-method -->

    
      <div id="method-i-add_buffer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_buffer</span><span
            class="method-args">(p1, p2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_buffer-source">
            <pre>static VALUE zipruby_archive_add_buffer(VALUE self, VALUE name, VALUE source) {
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  char *data;
  size_t len;

  Check_Type(name, T_STRING);
  Check_Type(source, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  len = RSTRING_LEN(source);

  if ((data = malloc(len)) == NULL) {
    rb_raise(rb_eRuntimeError, &quot;Add file failed: Cannot allocate memory&quot;);
  }

  memset(data, 0, len);
  memcpy(data, RSTRING_PTR(source), len);

  if ((zsource = zip_source_buffer(p_archive-&gt;archive, data, len, 1)) == NULL) {
    free(data);
    rb_raise(Error, &quot;Add file failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_add(p_archive-&gt;archive, RSTRING_PTR(name), zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add file failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- add_buffer-source -->
          
        </div>

        

        
      </div><!-- add_buffer-method -->

    
      <div id="method-i-add_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_dir</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_dir-source">
            <pre>static VALUE zipruby_archive_add_dir(VALUE self, VALUE name) {
  struct zipruby_archive *p_archive;

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_add_dir(p_archive-&gt;archive, RSTRING_PTR(name)) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add dir failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- add_dir-source -->
          
        </div>

        

        
      </div><!-- add_dir-method -->

    
      <div id="method-i-add_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_file</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_file-source">
            <pre>static VALUE zipruby_archive_add_file(int argc, VALUE *argv, VALUE self) {
  VALUE name, fname;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;fname);

  if (NIL_P(fname)) {
    fname = name;
    name = Qnil;
  }

  Check_Type(fname, T_STRING);

  if (NIL_P(name)) {
    name = rb_funcall(rb_cFile, rb_intern(&quot;basename&quot;), 1, fname);
  }

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if ((zsource = zip_source_file(p_archive-&gt;archive, RSTRING_PTR(fname), 0, -1)) == NULL) {
    rb_raise(Error, &quot;Add file failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_add(p_archive-&gt;archive, RSTRING_PTR(name), zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add file failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- add_file-source -->
          
        </div>

        

        
      </div><!-- add_file-method -->

    
      <div id="method-i-add_io" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_io</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_io-source">
            <pre>static VALUE zipruby_archive_add_io(int argc, VALUE *argv, VALUE self) {
  VALUE name, file, mtime;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  struct read_io *z;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;file);

  if (NIL_P(file)) {
    file = name;
    name = Qnil;
  }

  Check_IO(file);

  if (NIL_P(name)) {
    if (rb_obj_is_kind_of(file, rb_cFile)) {
      name = rb_funcall(rb_cFile, rb_intern(&quot;basename&quot;), 1, rb_funcall(file, rb_intern(&quot;path&quot;), 0));
    } else {
      rb_raise(rb_eRuntimeError, &quot;Add io failed - %s: Entry name is not given&quot;, RSTRING(rb_inspect(file)));
    }
  }

  if (rb_obj_is_kind_of(file, rb_cFile)) {
    mtime = rb_funcall(file, rb_intern(&quot;mtime&quot;), 0);
  } else {
    mtime = rb_funcall(rb_cTime, rb_intern(&quot;now&quot;), 0);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive); 
  Check_Archive(p_archive);

  if ((z = malloc(sizeof(struct read_io))) == NULL) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(rb_eRuntimeError, &quot;Add io failed - %s: Cannot allocate memory&quot;, RSTRING(rb_inspect(file)));
  }

  z-&gt;io = file;
  rb_ary_push(p_archive-&gt;sources, file);
  z-&gt;mtime = TIME2LONG(mtime);

  if ((zsource = zip_source_io(p_archive-&gt;archive, z)) == NULL) {
    free(z);
    rb_raise(Error, &quot;Add io failed - %s: %s&quot;, RSTRING(rb_inspect(file)), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_add(p_archive-&gt;archive, RSTRING_PTR(name), zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Add io failed - %s: %s&quot;, RSTRING_PTR(name), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- add_io-source -->
          
        </div>

        

        
      </div><!-- add_io-method -->

    
      <div id="method-i-add_or_replace" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_or_replace</span><span
            class="method-args">(p1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_or_replace-source">
            <pre>static VALUE zipruby_archive_add_or_replace_function(int argc, VALUE *argv, VALUE self) {
  VALUE name, mtime, flags;
  struct zipruby_archive *p_archive;
  int index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;name, &amp;mtime, &amp;flags);

  if (NIL_P(flags) &amp;&amp; FIXNUM_P(mtime)) {
    flags = mtime;
    mtime = Qnil;
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(name), i_flags);

  if (index &gt;= 0) {
    VALUE _args[] = { INT2NUM(index), mtime };
    return zipruby_archive_replace_function(2, _args, self);
  } else {
    VALUE _args[] = { name, mtime };
    return zipruby_archive_add_function(2, _args, self);
  }
}</pre>
          </div><!-- add_or_replace-source -->
          
        </div>

        

        
      </div><!-- add_or_replace-method -->

    
      <div id="method-i-add_or_replace_buffer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_or_replace_buffer</span><span
            class="method-args">(p1, p2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_or_replace_buffer-source">
            <pre>static VALUE zipruby_archive_add_or_replace_buffer(int argc, VALUE *argv, VALUE self) {
  struct zipruby_archive *p_archive;
  VALUE name, source, flags;
  int index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;source, &amp;flags);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(name), i_flags);

  if (index &gt;= 0) {
    VALUE _args[] = { INT2NUM(index), source };
    return zipruby_archive_replace_buffer(2, _args, self);
  } else {
    return zipruby_archive_add_buffer(self, name, source);
  }
}</pre>
          </div><!-- add_or_replace_buffer-source -->
          
        </div>

        

        
      </div><!-- add_or_replace_buffer-method -->

    
      <div id="method-i-add_or_replace_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_or_replace_file</span><span
            class="method-args">(p1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_or_replace_file-source">
            <pre>static VALUE zipruby_archive_add_or_replace_file(int argc, VALUE *argv, VALUE self) {
  VALUE name, fname, flags;
  struct zipruby_archive *p_archive;
  int index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;name, &amp;fname, &amp;flags);

  if (NIL_P(flags) &amp;&amp; FIXNUM_P(fname)) {
    flags = fname;
    fname = Qnil;
  }

  if (NIL_P(fname)) {
    fname = name;
    name = Qnil;
  }

  Check_Type(fname, T_STRING);

  if (NIL_P(name)) {
    name = rb_funcall(rb_cFile, rb_intern(&quot;basename&quot;), 1, fname);
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(name), i_flags);

  if (index &gt;= 0) {
    VALUE _args[] = { INT2NUM(index), fname };
    return zipruby_archive_replace_file(2, _args, self);
  } else {
    VALUE _args[] = { name, fname };
    return zipruby_archive_add_file(2, _args, self);
  }
}</pre>
          </div><!-- add_or_replace_file-source -->
          
        </div>

        

        
      </div><!-- add_or_replace_file-method -->

    
      <div id="method-i-add_or_replace_io" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_or_replace_io</span><span
            class="method-args">(p1, p2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_or_replace_io-source">
            <pre>static VALUE zipruby_archive_add_or_replace_io(int argc, VALUE *argv, VALUE self) {
  VALUE name, io, flags;
  struct zipruby_archive *p_archive;
  int index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;io, &amp;flags);
  Check_IO(io);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(name), i_flags);

  if (index &gt;= 0) {
    VALUE _args[] = {INT2NUM(index), io, flags};
    return zipruby_archive_replace_io(2, _args, self);
  } else {
    VALUE _args[2] = { name, io };
    return zipruby_archive_add_io(2, _args, self);
  }
}</pre>
          </div><!-- add_or_replace_io-source -->
          
        </div>

        

        
      </div><!-- add_or_replace_io-method -->

    
      <div id="method-i-close" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">close</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="close-source">
            <pre>static VALUE zipruby_archive_close(VALUE self) {
  struct zipruby_archive *p_archive;
  int changed, survivors;

  if (!zipruby_archive_is_open(self)) {
    return Qfalse;
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  changed = _zip_changed(p_archive-&gt;archive, &amp;survivors);

  if (zip_close(p_archive-&gt;archive) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Close archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  if (!NIL_P(p_archive-&gt;sources)){
    rb_ary_clear(p_archive-&gt;sources);
  }

  if (!NIL_P(p_archive-&gt;buffer) &amp;&amp; changed) {
    rb_funcall(p_archive-&gt;buffer, rb_intern(&quot;replace&quot;), 1, rb_funcall(self, rb_intern(&quot;read&quot;), 0));
  }

  zipruby_rmtmp(p_archive-&gt;tmpfilnam);
  p_archive-&gt;archive = NULL;
  p_archive-&gt;flags = 0;

  return Qtrue;
}</pre>
          </div><!-- close-source -->
          
        </div>

        

        
      </div><!-- close-method -->

    
      <div id="method-i-comment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">comment</span><span
            class="method-args">(p1 = v1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="comment-source">
            <pre>static VALUE zipruby_archive_get_comment(int argc, VALUE *argv, VALUE self) {
  VALUE flags;
  struct zipruby_archive *p_archive;
  const char *comment;
  int lenp, i_flags = 0;

  rb_scan_args(argc, argv, &quot;01&quot;, &amp;flags);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  // XXX: How is the error checked?
  comment = zip_get_archive_comment(p_archive-&gt;archive, &amp;lenp, i_flags);

  return comment ? rb_str_new(comment, lenp) : Qnil;
}</pre>
          </div><!-- comment-source -->
          
        </div>

        

        
      </div><!-- comment-method -->

    
      <div id="method-i-comment-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">comment=</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="comment-3D-source">
            <pre>static VALUE zipruby_archive_set_comment(VALUE self, VALUE comment) {
  struct zipruby_archive *p_archive;
  const char *s_comment = NULL;
  int len = 0;

  if (!NIL_P(comment)) {
    Check_Type(comment, T_STRING);
    s_comment = RSTRING_PTR(comment);
    len = RSTRING_LEN(comment);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_set_archive_comment(p_archive-&gt;archive, s_comment, len) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Comment archived failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- comment-3D-source -->
          
        </div>

        

        
      </div><!-- comment-3D-method -->

    
      <div id="method-i-commit" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">commit</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="commit-source">
            <pre>static VALUE zipruby_archive_commit(VALUE self) {
  struct zipruby_archive *p_archive;
  int changed, survivors;
  int errorp;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  changed = _zip_changed(p_archive-&gt;archive, &amp;survivors);

  if (zip_close(p_archive-&gt;archive) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Commit archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  if (!NIL_P(p_archive-&gt;sources)){
    rb_ary_clear(p_archive-&gt;sources);
  }

  if (!NIL_P(p_archive-&gt;buffer) &amp;&amp; changed) {
    rb_funcall(p_archive-&gt;buffer, rb_intern(&quot;replace&quot;), 1, rb_funcall(self, rb_intern(&quot;read&quot;), 0));
  }

  p_archive-&gt;archive = NULL;
  p_archive-&gt;flags = (p_archive-&gt;flags &amp; ~(ZIP_CREATE | ZIP_EXCL));

  if ((p_archive-&gt;archive = zip_open(RSTRING_PTR(p_archive-&gt;path), p_archive-&gt;flags, &amp;errorp)) == NULL) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Commit archive failed: %s&quot;, errstr);
  }

  return Qnil;
}</pre>
          </div><!-- commit-source -->
          
        </div>

        

        
      </div><!-- commit-method -->

    
      <div id="method-i-decrypt" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">decrypt</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="decrypt-source">
            <pre>static VALUE zipruby_archive_decrypt(VALUE self, VALUE password) {
  VALUE retval;
  struct zipruby_archive *p_archive;
  long pwdlen;
  int changed, survivors;
  int errorp;

  Check_Type(password, T_STRING);
  pwdlen = RSTRING_LEN(password);

  if (pwdlen &lt; 1) {
    rb_raise(Error, &quot;Decrypt archive failed: Password is empty&quot;);
  } else if (pwdlen &gt; 0xff) {
    rb_raise(Error, &quot;Decrypt archive failed: Password is too long&quot;);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  changed = _zip_changed(p_archive-&gt;archive, &amp;survivors);

  if (zip_close(p_archive-&gt;archive) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Decrypt archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  if (!NIL_P(p_archive-&gt;buffer) &amp;&amp; changed) {
    rb_funcall(p_archive-&gt;buffer, rb_intern(&quot;replace&quot;), 1, rb_funcall(self, rb_intern(&quot;read&quot;), 0));
  }

  p_archive-&gt;archive = NULL;
  p_archive-&gt;flags = (p_archive-&gt;flags &amp; ~(ZIP_CREATE | ZIP_EXCL));

  retval = zipruby_archive_s_decrypt(Archive, p_archive-&gt;path, password);

  if ((p_archive-&gt;archive = zip_open(RSTRING_PTR(p_archive-&gt;path), p_archive-&gt;flags, &amp;errorp)) == NULL) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Decrypt archive failed: %s&quot;, errstr);
  }

  return retval;
}</pre>
          </div><!-- decrypt-source -->
          
        </div>

        

        
      </div><!-- decrypt-method -->

    
      <div id="method-i-each" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">each</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="each-source">
            <pre>static VALUE zipruby_archive_each(VALUE self) {
  struct zipruby_archive *p_archive;
  int i, num_files;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);
  num_files = zip_get_num_files(p_archive-&gt;archive);

  for (i = 0; i &lt; num_files; i++) {
    VALUE file;
    int status;

    file = rb_funcall(File, rb_intern(&quot;new&quot;), 2, self, INT2NUM(i));
    rb_protect(rb_yield, file, &amp;status);
    rb_funcall(file, rb_intern(&quot;close&quot;), 0);

    if (status != 0) {
      rb_jump_tag(status);
    }
  }

  return Qnil;
}</pre>
          </div><!-- each-source -->
          
        </div>

        

        
      </div><!-- each-method -->

    
      <div id="method-i-encrypt" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">encrypt</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="encrypt-source">
            <pre>static VALUE zipruby_archive_encrypt(VALUE self, VALUE password) {
  VALUE retval;
  struct zipruby_archive *p_archive;
  long pwdlen;
  int changed, survivors;
  int errorp;

  Check_Type(password, T_STRING);
  pwdlen = RSTRING_LEN(password);

  if (pwdlen &lt; 1) {
    rb_raise(Error, &quot;Encrypt archive failed: Password is empty&quot;);
  } else if (pwdlen &gt; 0xff) {
    rb_raise(Error, &quot;Encrypt archive failed: Password is too long&quot;);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  changed = _zip_changed(p_archive-&gt;archive, &amp;survivors);

  if (zip_close(p_archive-&gt;archive) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Encrypt archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  if (!NIL_P(p_archive-&gt;buffer) &amp;&amp; changed) {
    rb_funcall(p_archive-&gt;buffer, rb_intern(&quot;replace&quot;), 1, rb_funcall(self, rb_intern(&quot;read&quot;), 0));
  }

  p_archive-&gt;archive = NULL;
  p_archive-&gt;flags = (p_archive-&gt;flags &amp; ~(ZIP_CREATE | ZIP_EXCL));

  retval = zipruby_archive_s_encrypt(Archive, p_archive-&gt;path, password);

  if ((p_archive-&gt;archive = zip_open(RSTRING_PTR(p_archive-&gt;path), p_archive-&gt;flags, &amp;errorp)) == NULL) {
    char errstr[ERRSTR_BUFSIZE];
    zip_error_to_str(errstr, ERRSTR_BUFSIZE, errorp, errno);
    rb_raise(Error, &quot;Encrypt archive failed: %s&quot;, errstr);
  }

  return retval;
}</pre>
          </div><!-- encrypt-source -->
          
        </div>

        

        
      </div><!-- encrypt-method -->

    
      <div id="method-i-fdelete" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fdelete</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="fdelete-source">
            <pre>static VALUE zipruby_archive_fdelete(VALUE self, VALUE index) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_delete(p_archive-&gt;archive, NUM2INT(index)) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Delete file failed at %d: %s&quot;, NUM2INT(index), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- fdelete-source -->
          
        </div>

        

        
      </div><!-- fdelete-method -->

    
      <div id="method-i-fopen" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fopen</span><span
            class="method-args">(p1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="fopen-source">
            <pre>static VALUE zipruby_archive_fopen(int argc, VALUE *argv, VALUE self) {
  VALUE index, flags, stat_flags, file;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;index, &amp;flags, &amp;stat_flags);
  file = rb_funcall(File, rb_intern(&quot;new&quot;), 4, self, index, flags, stat_flags);

  if (rb_block_given_p()) {
    VALUE retval;
    int status;

    retval = rb_protect(rb_yield, file, &amp;status);
    rb_funcall(file, rb_intern(&quot;close&quot;), 0);

    if (status != 0) {
      rb_jump_tag(status);
    }

    return retval;
  } else {
    return file;
  }
}</pre>
          </div><!-- fopen-source -->
          
        </div>

        

        
      </div><!-- fopen-method -->

    
      <div id="method-i-frename" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">frename</span><span
            class="method-args">(p1, p2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="frename-source">
            <pre>static VALUE zipruby_archive_frename(VALUE self, VALUE index, VALUE name) {
  struct zipruby_archive *p_archive;

  Check_Type(name, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_rename(p_archive-&gt;archive, NUM2INT(index), RSTRING_PTR(name)) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Rename file failed at %d: %s&quot;, NUM2INT(index), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- frename-source -->
          
        </div>

        

        
      </div><!-- frename-method -->

    
      <div id="method-i-frevert" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">frevert</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="frevert-source">
            <pre>static VALUE zipruby_archive_unchange(VALUE self) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_unchange_archive(p_archive-&gt;archive) == -1) {
    rb_raise(Error, &quot;Unchange archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- frevert-source -->
          
        </div>

        

        
      </div><!-- frevert-method -->

    
      <div id="method-i-funchange" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">funchange</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="funchange-source">
            <pre>static VALUE zipruby_archive_funchange(VALUE self, VALUE index) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_unchange(p_archive-&gt;archive, NUM2INT(index)) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Unchange file failed at %d: %s&quot;, NUM2INT(index), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- funchange-source -->
          
        </div>

        

        
      </div><!-- funchange-method -->

    
      <div id="method-i-funchange_all" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">funchange_all</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="funchange_all-source">
            <pre>static VALUE zipruby_archive_funchange_all(VALUE self) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_unchange_all(p_archive-&gt;archive) == -1) {
    rb_raise(Error, &quot;Unchange all file failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- funchange_all-source -->
          
        </div>

        

        
      </div><!-- funchange_all-method -->

    
      <div id="method-i-get_comment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_comment</span><span
            class="method-args">(p1 = v1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_comment-source">
            <pre>static VALUE zipruby_archive_get_comment(int argc, VALUE *argv, VALUE self) {
  VALUE flags;
  struct zipruby_archive *p_archive;
  const char *comment;
  int lenp, i_flags = 0;

  rb_scan_args(argc, argv, &quot;01&quot;, &amp;flags);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  // XXX: How is the error checked?
  comment = zip_get_archive_comment(p_archive-&gt;archive, &amp;lenp, i_flags);

  return comment ? rb_str_new(comment, lenp) : Qnil;
}</pre>
          </div><!-- get_comment-source -->
          
        </div>

        

        
      </div><!-- get_comment-method -->

    
      <div id="method-i-get_fcomment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_fcomment</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_fcomment-source">
            <pre>static VALUE zipruby_archive_get_fcomment(int argc, VALUE *argv, VALUE self) {
  VALUE index, flags;
  struct zipruby_archive *p_archive;
  const char *comment;
  int lenp, i_flags = 0;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;index, &amp;flags);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  // XXX: How is the error checked?
  comment = zip_get_file_comment(p_archive-&gt;archive, NUM2INT(index), &amp;lenp, i_flags);

  return comment ? rb_str_new(comment, lenp) : Qnil;
}</pre>
          </div><!-- get_fcomment-source -->
          
        </div>

        

        
      </div><!-- get_fcomment-method -->

    
      <div id="method-i-get_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_name</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_name-source">
            <pre>static VALUE zipruby_archive_get_name(int argc, VALUE *argv, VALUE self) {
  VALUE index, flags;
  struct zipruby_archive *p_archive;
  int i_flags = 0;
  const char *name;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;index, &amp;flags);
  Check_Type(index, T_FIXNUM);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if ((name = zip_get_name(p_archive-&gt;archive, NUM2INT(index), i_flags)) == NULL) {
    rb_raise(Error, &quot;Get name failed at %d: %s&quot;, index, zip_strerror(p_archive-&gt;archive));
  }

  return (name != NULL) ? rb_str_new2(name) : Qnil;
}</pre>
          </div><!-- get_name-source -->
          
        </div>

        

        
      </div><!-- get_name-method -->

    
      <div id="method-i-get_stat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_stat</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_stat-source">
            <pre>static VALUE zipruby_archive_get_stat(int argc, VALUE *argv, VALUE self) {
  VALUE index, flags;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;index, &amp;flags);

  return rb_funcall(Stat, rb_intern(&quot;new&quot;), 3, self, index, flags);
}</pre>
          </div><!-- get_stat-source -->
          
        </div>

        

        
      </div><!-- get_stat-method -->

    
      <div id="method-i-locate_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">locate_name</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="locate_name-source">
            <pre>static VALUE zipruby_archive_locate_name(int argc, VALUE *argv, VALUE self) {
  VALUE fname, flags;
  struct zipruby_archive *p_archive;
  int i_flags = 0;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;flags);
  Check_Type(fname, T_STRING);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  return INT2NUM(zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(fname), i_flags));
}</pre>
          </div><!-- locate_name-source -->
          
        </div>

        

        
      </div><!-- locate_name-method -->

    
      <div id="method-i-num_files" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">num_files</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="num_files-source">
            <pre>static VALUE zipruby_archive_num_files(VALUE self) {
  struct zipruby_archive *p_archive;
  int num_files;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);
  num_files = zip_get_num_files(p_archive-&gt;archive);

  return INT2NUM(num_files);
}</pre>
          </div><!-- num_files-source -->
          
        </div>

        

        
      </div><!-- num_files-method -->

    
      <div id="method-i-open-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">open?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="open-3F-source">
            <pre>static VALUE zipruby_archive_is_open(VALUE self) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  return (p_archive-&gt;archive != NULL) ? Qtrue : Qfalse;
}</pre>
          </div><!-- open-3F-source -->
          
        </div>

        

        
      </div><!-- open-3F-method -->

    
      <div id="method-i-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>static VALUE zipruby_archive_read(VALUE self) {
  VALUE retval = Qnil;
  struct zipruby_archive *p_archive;
  FILE *fzip;
  char buf[DATA_BUFSIZE];
  ssize_t n;
  int block_given;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);

  if (NIL_P(p_archive-&gt;path)) {
    rb_raise(rb_eRuntimeError, &quot;invalid Zip::Archive&quot;);
  }

#ifdef _WIN32
  if (fopen_s(&amp;fzip, RSTRING_PTR(p_archive-&gt;path), &quot;rb&quot;) != 0) {
    rb_raise(Error, &quot;Read archive failed: Cannot open archive&quot;);
  }
#else
  if ((fzip = fopen(RSTRING_PTR(p_archive-&gt;path), &quot;rb&quot;)) == NULL) {
    rb_raise(Error, &quot;Read archive failed: Cannot open archive&quot;);
  }
#endif

  block_given = rb_block_given_p();

  while ((n = fread(buf, 1, sizeof(buf), fzip)) &gt; 0) {
    if (block_given) {
      rb_yield(rb_str_new(buf, n));
    } else {
      if (NIL_P(retval)) {
        retval = rb_str_new(buf, n);
      } else {
        rb_str_buf_cat(retval, buf, n);
      }
    }
  }

#if defined(RUBY_VM) &amp;&amp; defined(_WIN32)
  _fclose_nolock(fzip);
#elif defined(RUBY_WIN32_H)
#undef fclose
  fclose(fzip);
#define fclose(f) rb_w32_fclose(f)
#else
  fclose(fzip);
#endif

  if (n == -1) {
    rb_raise(Error, &quot;Read archive failed&quot;);
  }

  return retval;
}</pre>
          </div><!-- read-source -->
          
        </div>

        

        
      </div><!-- read-method -->

    
      <div id="method-i-replace" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace</span><span
            class="method-args">(p1, p2 = v2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="replace-source">
            <pre>static VALUE zipruby_archive_replace_function(int argc, VALUE *argv, VALUE self) {
  VALUE index, flags, mtime;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  struct read_proc *z;
  int i_index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;12&quot;, &amp;index, &amp;mtime, &amp;flags);
  rb_need_block();

  if (TYPE(index) != T_STRING &amp;&amp; !FIXNUM_P(index)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Fixnum or String)&quot;, rb_class2name(CLASS_OF(index)));
  }

  if (NIL_P(mtime)) {
    mtime = rb_funcall(rb_cTime, rb_intern(&quot;now&quot;), 0);
  } else if (!rb_obj_is_instance_of(mtime, rb_cTime)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Time)&quot;, rb_class2name(CLASS_OF(mtime)));
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive); 
  Check_Archive(p_archive);

  if (FIXNUM_P(index)) {
    i_index = NUM2INT(index);
  } else if ((i_index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(index), i_flags)) == -1) {
    rb_raise(Error, &quot;Replace file failed - %s: Archive does not contain a file&quot;, RSTRING_PTR(index));
  }

  if ((z = malloc(sizeof(struct read_proc))) == NULL) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(rb_eRuntimeError, &quot;Replace failed at %d: Cannot allocate memory&quot;, i_index);
  }

  z-&gt;proc = rb_block_proc();
  rb_ary_push(p_archive-&gt;sources, z-&gt;proc);
  z-&gt;mtime = TIME2LONG(mtime);

  if ((zsource = zip_source_proc(p_archive-&gt;archive, z)) == NULL) {
    free(z);
    rb_raise(Error, &quot;Replace failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  if (zip_replace(p_archive-&gt;archive, i_index, zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Replace failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- replace-source -->
          
        </div>

        

        
      </div><!-- replace-method -->

    
      <div id="method-i-replace_buffer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace_buffer</span><span
            class="method-args">(p1, p2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="replace_buffer-source">
            <pre>static VALUE zipruby_archive_replace_buffer(int argc, VALUE *argv, VALUE self) {
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  VALUE index, source, flags;
  int i_index, i_flags = 0;
  char *data;
  size_t len;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;index, &amp;source, &amp;flags);

  if (TYPE(index) != T_STRING &amp;&amp; !FIXNUM_P(index)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Fixnum or String)&quot;, rb_class2name(CLASS_OF(index)));
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(source, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (FIXNUM_P(index)) {
    i_index = NUM2INT(index);
  } else if ((i_index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(index), i_flags)) == -1) {
    rb_raise(Error, &quot;Replace file failed - %s: Archive does not contain a file&quot;, RSTRING_PTR(index));
  }

  len = RSTRING_LEN(source);

  if ((data = malloc(len)) == NULL) {
    rb_raise(rb_eRuntimeError, &quot;Replace file failed: Cannot allocate memory&quot;);
  }

  memcpy(data, RSTRING_PTR(source), len);

  if ((zsource = zip_source_buffer(p_archive-&gt;archive, data, len, 1)) == NULL) {
    free(data);
    rb_raise(Error, &quot;Replace file failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  if (zip_replace(p_archive-&gt;archive, i_index, zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Replace file failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- replace_buffer-source -->
          
        </div>

        

        
      </div><!-- replace_buffer-method -->

    
      <div id="method-i-replace_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace_file</span><span
            class="method-args">(p1, p2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="replace_file-source">
            <pre>static VALUE zipruby_archive_replace_file(int argc, VALUE* argv, VALUE self) {
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  VALUE index, fname, flags;
  int i_index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;index, &amp;fname, &amp;flags);

  if (TYPE(index) != T_STRING &amp;&amp; !FIXNUM_P(index)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Fixnum or String)&quot;, rb_class2name(CLASS_OF(index)));
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Check_Type(fname, T_STRING);
  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (FIXNUM_P(index)) {
    i_index = NUM2INT(index);
  } else if ((i_index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(index), i_flags)) == -1) {
    rb_raise(Error, &quot;Replace file failed - %s: Archive does not contain a file&quot;, RSTRING_PTR(index));
  }

  if ((zsource = zip_source_file(p_archive-&gt;archive, RSTRING_PTR(fname), 0, -1)) == NULL) {
    rb_raise(Error, &quot;Replace file failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  if (zip_replace(p_archive-&gt;archive, i_index, zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Replace file failed at %d: %s&quot;, i_index, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- replace_file-source -->
          
        </div>

        

        
      </div><!-- replace_file-method -->

    
      <div id="method-i-replace_io" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace_io</span><span
            class="method-args">(p1, p2, p3 = v3)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="replace_io-source">
            <pre>static VALUE zipruby_archive_replace_io(int argc, VALUE *argv, VALUE self) {
  VALUE file, index, flags, mtime;
  struct zipruby_archive *p_archive;
  struct zip_source *zsource;
  struct read_io *z;
  int i_index, i_flags = 0;

  rb_scan_args(argc, argv, &quot;21&quot;, &amp;index, &amp;file, &amp;flags);

  if (TYPE(index) != T_STRING &amp;&amp; !FIXNUM_P(index)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Fixnum or String)&quot;, rb_class2name(CLASS_OF(index)));
  }

  Check_IO(file);

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  if (rb_obj_is_kind_of(file, rb_cFile)) {
    mtime = rb_funcall(file, rb_intern(&quot;mtime&quot;), 0);
  } else {
    mtime = rb_funcall(rb_cTime, rb_intern(&quot;now&quot;), 0);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (FIXNUM_P(index)) {
    i_index = NUM2INT(index);
  } else if ((i_index = zip_name_locate(p_archive-&gt;archive, RSTRING_PTR(index), i_flags)) == -1) {
    rb_raise(Error, &quot;Replace io failed - %s: Archive does not contain a file&quot;, RSTRING_PTR(index));
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive); 
  Check_Archive(p_archive);

  if ((z = malloc(sizeof(struct read_io))) == NULL) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(rb_eRuntimeError, &quot;Replace io failed at %d - %s: Cannot allocate memory&quot;, i_index, RSTRING(rb_inspect(file)));
  }

  z-&gt;io = file;
  rb_ary_push(p_archive-&gt;sources, file);
  z-&gt;mtime = TIME2LONG(mtime);

  if ((zsource = zip_source_io(p_archive-&gt;archive, z)) == NULL) {
    free(z);
    rb_raise(Error, &quot;Replace io failed at %d - %s: %s&quot;, i_index, RSTRING(rb_inspect(file)), zip_strerror(p_archive-&gt;archive));
  }

  if (zip_replace(p_archive-&gt;archive, i_index, zsource) == -1) {
    zip_source_free(zsource);
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Replace io failed at %d - %s: %s&quot;, i_index, RSTRING(rb_inspect(file)), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- replace_io-source -->
          
        </div>

        

        
      </div><!-- replace_io-method -->

    
      <div id="method-i-revert" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">revert</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="revert-source">
            <pre>static VALUE zipruby_archive_revert(VALUE self) {
  zipruby_archive_funchange_all(self);
  zipruby_archive_unchange(self);

  return Qnil;
}</pre>
          </div><!-- revert-source -->
          
        </div>

        

        
      </div><!-- revert-method -->

    
      <div id="method-i-set_fcomment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">set_fcomment</span><span
            class="method-args">(p1, p2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="set_fcomment-source">
            <pre>static VALUE zipruby_archive_set_fcomment(VALUE self, VALUE index, VALUE comment) {
  struct zipruby_archive *p_archive;
  char *s_comment = NULL;
  int len = 0;

  if (!NIL_P(comment)) {
    Check_Type(comment, T_STRING);
    s_comment = RSTRING_PTR(comment);
    len = RSTRING_LEN(comment);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_set_file_comment(p_archive-&gt;archive, NUM2INT(index), s_comment, len) == -1) {
    zip_unchange_all(p_archive-&gt;archive);
    zip_unchange_archive(p_archive-&gt;archive);
    rb_raise(Error, &quot;Comment file failed at %d: %s&quot;, NUM2INT(index), zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- set_fcomment-source -->
          
        </div>

        

        
      </div><!-- set_fcomment-method -->

    
      <div id="method-i-unchange" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unchange</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="unchange-source">
            <pre>static VALUE zipruby_archive_unchange(VALUE self) {
  struct zipruby_archive *p_archive;

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);

  if (zip_unchange_archive(p_archive-&gt;archive) == -1) {
    rb_raise(Error, &quot;Unchange archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
  }

  return Qnil;
}</pre>
          </div><!-- unchange-source -->
          
        </div>

        

        
      </div><!-- unchange-method -->

    
      <div id="method-i-update" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">update</span><span
            class="method-args">(p1, p2 = v2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="update-source">
            <pre>static VALUE zipruby_archive_update(int argc, VALUE *argv, VALUE self) {
  struct zipruby_archive *p_archive, *p_srcarchive;
  VALUE srcarchive, flags;
  int i, num_files, i_flags = 0;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;srcarchive, &amp;flags);

  if (!rb_obj_is_instance_of(srcarchive, Archive)) {
    rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Zip::Archive)&quot;, rb_class2name(CLASS_OF(srcarchive)));
  }

  if (!NIL_P(flags)) {
    i_flags = NUM2INT(flags);
  }

  Data_Get_Struct(self, struct zipruby_archive, p_archive);
  Check_Archive(p_archive);
  Data_Get_Struct(srcarchive, struct zipruby_archive, p_srcarchive);
  Check_Archive(p_srcarchive);

  num_files = zip_get_num_files(p_srcarchive-&gt;archive);

  for (i = 0; i &lt; num_files; i++) {
    struct zip_source *zsource;
    struct zip_file *fzip;
    struct zip_stat sb;
    char *buf;
    const char *name;
    int index, error;

    zip_stat_init(&amp;sb);

    if (zip_stat_index(p_srcarchive-&gt;archive, i, 0, &amp;sb)) {
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_srcarchive-&gt;archive));
    }

    if ((buf = malloc(sb.size)) == NULL) {
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(rb_eRuntimeError, &quot;Update archive failed: Cannot allocate memory&quot;);
    }

    fzip = zip_fopen_index(p_srcarchive-&gt;archive, i, 0);

    if (fzip == NULL) {
      free(buf);
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_srcarchive-&gt;archive));
    }

    if (zip_fread(fzip, buf, sb.size) == -1) {
      free(buf);
      zip_fclose(fzip);
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_file_strerror(fzip));
    }

    if ((error = zip_fclose(fzip)) != 0) {
      char errstr[ERRSTR_BUFSIZE];
      free(buf);
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      zip_error_to_str(errstr, ERRSTR_BUFSIZE, error, errno);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, errstr);
    }

    if ((zsource = zip_source_buffer(p_archive-&gt;archive, buf, sb.size, 1)) == NULL) {
      free(buf);
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
    }

    if ((name = zip_get_name(p_srcarchive-&gt;archive, i, 0)) == NULL) {
      zip_source_free(zsource);
      zip_unchange_all(p_archive-&gt;archive);
      zip_unchange_archive(p_archive-&gt;archive);
      rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_srcarchive-&gt;archive));
    }

    index = zip_name_locate(p_archive-&gt;archive, name, i_flags);

    if (index &gt;= 0) {
      if (zip_replace(p_archive-&gt;archive, i, zsource) == -1) {
        zip_source_free(zsource);
        zip_unchange_all(p_archive-&gt;archive);
        zip_unchange_archive(p_archive-&gt;archive);
        rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
      }
    } else {
      if (zip_add(p_archive-&gt;archive, name, zsource) == -1) {
        zip_source_free(zsource);
        zip_unchange_all(p_archive-&gt;archive);
        zip_unchange_archive(p_archive-&gt;archive);
        rb_raise(Error, &quot;Update archive failed: %s&quot;, zip_strerror(p_archive-&gt;archive));
      }
    }
  }

  return Qnil;
}</pre>
          </div><!-- update-source -->
          
        </div>

        

        
      </div><!-- update-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.11.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

